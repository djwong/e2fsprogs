#!/bin/bash

#  Copyright (C) 2018 Oracle.  All Rights Reserved.
#
#  Author: Darrick J. Wong <darrick.wong@oracle.com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it would be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write the Free Software Foundation,
#  Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.

# Check all ext[234] filesystems mounted on LVM
types="ext2,ext3,ext4"

exitcode() {
	ret="$1"

	# If we're being run as a service, the return code must fit the LSB
	# init script action error guidelines, which is to say that we
	# compress all errors to 1 ("generic or unspecified error", LSB 5.0
	# section 22.2) and hope the admin will scan the log for what
	# actually happened.

	# We have to sleep 2 seconds here because journald uses the pid to
	# connect our log messages to the systemd service.  This is critical
	# for capturing all the log messages if the scrub fails, because the
	# fail service uses the service name to gather log messages for the
	# error report.
	if [ -n "${SERVICE_MODE}" ]; then
		test "${ret}" -ne 0 && ret=1
		test -x "${SLEEP_PROG}" && "${SLEEP_PROG}" 2
	fi

	exit "${ret}"
}

prog_path() {
	path="$1"
	displayname="$2"

	if ! type -P "${path}" && [ -n "${displayname}" ]; then
		echo "${displayname}: Command not found."
		exitcode 8
	fi
}

LVS_PROG="$(prog_path "@root_sbindir@/lvs" "lvs")"
BLKID_PROG="$(prog_path "@root_sbindir@/blkid" "blkid")"
SYSTEMCTL_PROG="$(prog_path "@root_bindir@/systemctl")"
SLEEP_PROG="$(prog_path "@root_bindir@/sleep")"

# Scrub any fs on lvm by creating a snapshot and fscking that.
"${LVS_PROG}" -o vg_name,lv_name,lv_role --noheadings 2> /dev/null | while read vg lv role extra; do
	# parsing error?
	test -n "${extra}" && continue
	# Skip snapshots
	echo "${role}" | grep -q "snapshot" && continue

	dev="/dev/${vg}/${lv}"
	# Skip non-ext[234]
	"${BLKID_PROG}" -p -n "${types}" "${dev}" > /dev/null 2>&1 || continue

	if [ ! -x "${SYSTEMCTL_PROG}" ]; then
		${DBG} "@root_sbindir@/e2scrub" "${dev}"
	else
		${DBG} "${SYSTEMCTL_PROG}" start "e2scrub@${dev}" 2> /dev/null
		res=$?
		if [ "${res}" -ne 0 ] && [ "${res}" -ne 1 ]; then
			${DBG} "@root_sbindir@/e2scrub" "${dev}"
		fi
	fi
done

exitcode 0
